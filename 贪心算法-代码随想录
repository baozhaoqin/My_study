1.贪心算法的理论基础
*局部最优推出全局最优*
贪心无套路，总是东一下西一下
如果找到局部最优，然后推出整体最优，那么就是贪心（如果感觉好像局部最优可以推出全局最优，然后想不到反例，那就试一试贪心吧！）
2.分发饼干（455）
本题解法：先发大饼干满足大胃口的小孩
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 先排序
        g = sorted(g)
        s = sorted(s)
        count = 0
        # 定义最大的饼干索引
        index = len(s) - 1
        # 遍历胃口,从最大的胃口开始
        for i in range(len(g)-1,-1,-1):
            # 找到适合胃口的饼干
            # 注意这里使用的是if语句
            if index >= 0 and s[index] >= g[i]:
                count += 1
                index -= 1
        return count
3.摆动序列
有三种情况需要考虑
（1）上下有平坡
（2）首尾元素
（3）单调有平坡，就是要么前后差值一直为正数或者负数。
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        # 特殊情况处理
        if len(nums) == 1 : return 1
        # 初始化
        prediff = 0
        curdiff = 0
        # 结果集，初始化为1是考虑到了最后一个点也是作为摆动的
        result = 1
        # 循环，减一是由于结果集已经将最后一个点作为了摆动，所以不必到达最后一个点了
        for i in range(len(nums)-1):
            curdiff = nums[i+1] - nums[i]
            if prediff >= 0 and curdiff < 0 or prediff <= 0 and curdiff >0:
                result += 1
                # 更新前差值，在这里更新是为了适应摆动的时候，才更新前差值
                prediff = curdiff 
        return result
4.最大子序和
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 定义存储最大连续和的res变量
        res = float('-inf')  # 初始化结果为负无穷大
        # 定义连续和
        count = 0
        # 循环
        for i in range(len(nums)):
            # 连续和
            count += nums[i]
            # 更新最大连续和
            if count > res : res = count
            # 如果连续和是负数，则可以选择下一个数作为连续和的起点
            # 这里连续和等于零，其实也可以作为下一个数作为连续和的起点（只不过数组元素会增加）
            # 这里直接定义连续和为0，因为下一次循环的时候就会加上下一个数作为起点了
            if count < 0 : count = 0
            # if count <= 0 : count = 0
        return res
5.买卖股票的最佳时机 II
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 定义收集正收益的结果集
        res = 0
        # 遍历，这里索引从1开始，是为了能够计算出收益
        for i in range(1,len(prices)):
            # 如果是正收益则加入到结果集
            # 这里用到了与0相比取最大值的方法来确认正数
            res += max(prices[i]-prices[i-1],0)
        return res
6.跳跃游戏
class Solution:
    def canJump(self, nums: List[int]) -> bool:        
        # 定义覆盖范围
        cover = 0
        # 特殊情况处理
        if len(nums) == 1: return True
        i = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover:
            # 这一步是选择最大的覆盖范围
            cover = max(i + nums[i], cover)
            if cover >= len(nums) - 1: return True
            i += 1
        return False
7.跳跃游戏 II
8.K次取反后最大化的数组和

