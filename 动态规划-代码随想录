1.理论基础
五部曲
dp数组以及下标的含义
递推公式
dp数组如何初始化
遍历顺序
打印dp数组
2.斐波那契数
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        dp = [0] * n
        dp[0],dp[1] = 1,1
        for i in range(2,len(dp)):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n-1]
3.爬楼梯
难点怎么推出递推公式
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return n
        # 这样子初始化才是有意义的
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]
4.使用最小花费爬楼梯
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost) + 1)
        dp[0] = 0  # 初始值，表示从起点开始不需要花费体力
        dp[1] = 0  # 初始值，表示经过第一步不需要花费体力
        
        for i in range(2, len(cost) + 1):
            # 在第i步，可以选择从前一步（i-1）花费体力到达当前步，或者从前两步（i-2）花费体力到达当前步
            # 选择其中花费体力较小的路径，加上当前步的花费，更新dp数组
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        
        return dp[len(cost)]  # 返回到达楼顶的最小花费
5.不同路径
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # dp数组含义，到达时有多少条路径
        dp = [[0] * n for _ in range(m)]
        # 递推公式
        # dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # 如何初始化，将第一行与第一列都设为1，因为题意要求只可走左或下
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        # 遍历顺序，从左往右，从上往下
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]
6.不同路径 II
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # 特殊情况处理，要么起点有障碍物要么终点有
        if obstacleGrid[m-1][n-1] == 1 or obstacleGrid[-1][-1] == 1 : return 0
        # dp数组含义，到达时有多少条路径
        dp = [[0] * n for _ in range(m)]
        # 递推公式
        # dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # 如何初始化，将第一行与第一列都设为1，因为题意要求只可走左或下
        for i in range(m):
            # 增加判断障碍物的条件
            if obstacleGrid[i][0] == 0:
                dp[i][0] = 1
            else : break
        for j in range(n):
            # 增加判断障碍物的条件
            if obstacleGrid[0][j] == 0:
                dp[0][j] = 1
            else : break
        # 遍历顺序，从左往右，从上往下
        for i in range(1,m):
            for j in range(1,n):
                # 增加判断障碍物的条件
                if obstacleGrid[i][j] == 1:
                    continue
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[m-1][n-1]     
7.整数拆分

8.不同的二叉搜索树

9.01背包理论基础
理解dp数组的含义
递推公式的推导
10.01背包理论基础（滚动数组）
注意一下遍历顺序
11.分割等和子集
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # 思路：能够找到加起来等于总和一半的数或者数的总和就说明可以分割
        # 一维DP
        total_sum = sum(nums)
        if total_sum % 2 != 0:
            return False
        target_sum = total_sum // 2
        # DP数组的含义
        dp = [False] * (target_sum + 1)
        # 初始化
        dp[0] = True
        # 遍历顺序，从后往前
        for num in nums:
            # 从target_sum逆序迭代到num，步长为-1
            for i in range(target_sum, num - 1, -1):
                dp[i] = dp[i] or dp[i - num]
        return dp[target_sum]
